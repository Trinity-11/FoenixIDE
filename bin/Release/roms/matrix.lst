
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass.exe --long-address -x --intel-hex -o matrix.hex --list matrix.lst matrix.asm
; Wed Aug 07 21:08:32 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: matrix.asm


;******  Processing file: macros_inc.asm


;******  Return to file: matrix.asm


;******  Processing file: page_00_inc.asm

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				unused_0000      = $000000 ;12 Bytes unused
=$000008				OPL2_ADDY_PTR_LO = $000008  ; THis Points towards the Instruments Database
=$000009				OPL2_ADDY_PTR_MD = $000009
=$00000a				OPL2_ADDY_PTR_HI = $00000A
=$00000c				SCREENBEGIN      = $00000C ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$00000f				COLS_VISIBLE     = $00000F ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000011				COLS_PER_LINE    = $000011 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000013				LINES_VISIBLE    = $000013 ;2 Bytes The number of rows visible on the screen. Default=25
=$000015				LINES_MAX        = $000015 ;2 Bytes The number of rows in memory for the screen. Default=64
=$000017				CURSORPOS        = $000017 ;3 Bytes The next character written to the screen will be written in this location.
=$00001a				CURSORX          = $00001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001c				CURSORY          = $00001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001e				CURCOLOR         = $00001E ;2 Bytes Color of next character to be printed to the screen.
=$000020				CURATTR          = $000020 ;2 Bytes Attribute of next character to be printed to the screen.
=$000022				STACKBOT         = $000022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000024				STACKTOP         = $000024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$000026				OPL2_OPERATOR    = $000026 ;
=$000027				OPL2_CHANNEL     = $000027 ;
=$000028				OPL2_REG_REGION  = $000028 ; Offset to the Group of Registers
=$00002a				OPL2_REG_OFFSET  = $00002A ; 2 Bytes (16Bits)
=$00002c				OPL2_IND_ADDY_LL = $00002C ; 2 Bytes Reserved (Only need 3)
=$00002e				OPL2_IND_ADDY_HL = $00002E ; 2 Bytes Reserved (Only need 3)
=$000030				OPL2_NOTE        = $000030 ; 1 Byte
=$000031				OPL2_OCTAVE      = $000031 ; 1 Byte
=$000032				OPL2_PARAMETER0  = $000032 ; 1 Byte - Key On/Feedback
=$000033				OPL2_PARAMETER1  = $000033 ; 1 Byte
=$000034				OPL2_PARAMETER2  = $000034 ; 1 Byte
=$000035				OPL2_PARAMETER3  = $000035 ; 1 Byte
=$000036				OPL2_LOOP        = $000036 ;
=$000036				OPL2_BLOCK       = $000036
=$000038				SDCARD_FILE_PTR  = $000038 ; 3 Bytes Pointer to Filename to open
=$00003c				SDCARD_BYTE_NUM  = $00003C ; 2Bytes
=$00003f				SDCARD_PRSNT_MNT = $00003F ; 1 Byte, Indicate that the SDCard is Present and that it is Mounted
=$000040				CMD_PARSER_TMPX  = $000040 ; <<< Command Parser 2Bytes
=$000042				CMD_PARSER_TMPY  = $000042 ; <<< Command Parser 2Bytes
=$000044				CMD_LIST_PTR     = $000044 ; <<< Command Parser 3 Bytes
=$000048				CMD_PARSER_PTR   = $000048 ; <<< Command Parser 3 Bytes
=$00004b				CMD_ATTRIBUTE    = $00004B ; <<< Command Parser 2 Bytes (16bits Attribute Field)
=$00004d				CMD_EXEC_ADDY    = $00004D ; <<< Command Parser 3 Bytes 24 Bits Address Jump to execute the Command
=$000050				KEY_BUFFER_RPOS  = $000050 ;
=$000052				KEY_BUFFER_WPOS  = $000052 ;
=$000054				CMD_VARIABLE_TMP = $000054 ;
=$000056				CMD_ARG_DEV      = $000056 ;
=$000057				CMD_ARG_SA       = $000057 ;
=$00005a				CMD_ARG_EA       = $00005A ;
=$00005d				CMD_VALID        = $00005D ;
=$000040				BM_CLEAR_SCRN_X  = $000040
=$000042				BM_CLEAR_SCRN_Y  = $000042
=$000040				RAD_STARTLINE    = $000040 ; 1 Byte
=$000041				RAD_PATTERN_IDX  = $000041 ; 1 Byte
=$000042				RAD_LINE         = $000042 ; 1 Byte
=$000043				RAD_LINENUMBER   = $000043 ; 1 Byte
=$000044				RAD_CHANNEL_NUM  = $000044 ; 1 Byte
=$000045				RAD_ISLASTCHAN   = $000045 ; 1 Byte
=$000046				RAD_Y_POINTER    = $000046 ; 2 Bytes
=$000048				RAD_TICK         = $000048
=$00004a				RAD_CHANNEL_DATA = $00004A ; 2 Bytes
=$00004c				RAD_CHANNE_EFFCT = $00004C
=$00004d				RAD_TEMP         = $00004D
=$000040				BMP_X_SIZE       = $000040 ; 2 Bytes
=$000042				BMP_Y_SIZE       = $000042 ; 2 Bytes
=$000044				BMP_PRSE_SRC_PTR = $000044 ; 3 Bytes
=$000048				BMP_PRSE_DST_PTR = $000048 ; 3 Bytes
=$00004c				BMP_COLOR_PALET  = $00004C ; 2 Bytes
=$00004e				SCRN_X_STRIDE    = $00004E ; 2 Bytes, Basically How many Pixel Accross in Bitmap Mode
=$000050				BMP_FILE_SIZE    = $000050 ; 4 Bytes
=$000054				BMP_POSITION_X   = $000054 ; 2 Bytes Where, the BMP will be position on the X Axis
=$000056				BMP_POSITION_Y   = $000056 ; 2 Bytes Where, the BMP will be position on the Y Axis
=$000058				BMP_PALET_CHOICE = $000058 ;
=$0000e0				MOUSE_PTR        = $0000E0
=$0000e1				MOUSE_POS_X_LO   = $0000E1
=$0000e2				MOUSE_POS_X_HI   = $0000E2
=$0000e3				MOUSE_POS_Y_LO   = $0000E3
=$0000e4				MOUSE_POS_Y_HI   = $0000E4
=$0000f0				USER_TEMP        = $0000F0 ;32 Bytes Temp space for user programs
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved, overlaps debugging registers at $1F0
=$000100				MULTIPLIER_0     = $000100 ;0 Byte  Unsigned multiplier
=$000100				M0_OPERAND_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				M0_OPERAND_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				M0_RESULT        = $000104 ;4 Bytes Result of A x B
=$000108				MULTIPLIER_1     = $000108 ;0 Byte  Signed Multiplier
=$000108				M1_OPERAND_A     = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				M1_OPERAND_B     = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				M1_RESULT        = $00010C ;4 Bytes Result of A x B
=$000118				DIVIDER_1        = $000118 ;0 Byte  Unsigned divider
=$000118				D1_OPERAND_A     = $000118 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$00011a				D1_OPERAND_B     = $00011A ;2 Bytes Divider 0 Divisor ex B in A/B
=$00011c				D1_RESULT        = $00011C ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$00011e				D1_REMAINDER     = $00011E ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000110				DIVIDER_0        = $000110 ;0 Byte  Signed divider
=$000110				D0_OPERAND_A     = $000110 ;2 Bytes Divider 1 Dividend ex: A in  A/B
=$000112				D0_OPERAND_B     = $000112 ;2 Bytes Divider 1 Divisor ex B in A/B
=$000114				D0_RESULT        = $000114 ;2 Bytes Signed quotient result of A/B ex: 7/2 = 3 r 1
=$000116				D0_REMAINDER     = $000116 ;2 Bytes Signed remainder of A/B ex: 1 in 7/2=3 r 1
=$000120				ADDER_SIGNED_32  = $000120 ; The 32 Bit Adders takes 12Byte that are NOT RAM Location
=$000140				INT_CONTROLLER   = $000140 ; $000140...$00015F Interrupt Controller
=$000160				TIMER_CONTROLLER = $000160 ; $000160...$00017F Timer0/Timer1/Timer2 Block
=$000160				TIMER_CTRL_REGLL = $000160 ;
=$000161				TIMER_CTRL_REGLH = $000161 ;
=$000162				TIMER_CTRL_REGHL = $000162 ;
=$000163				TIMER_CTRL_REGHH = $000163 ;
=$000240				CPU_REGISTERS    = $000240 ; Byte
=$000240				CPUPC            = $000240 ;2 Bytes Program Counter (PC)
=$000242				CPUPBR           = $000242 ;2 Bytes Program Bank Register (K)
=$000244				CPUA             = $000244 ;2 Bytes Accumulator (A)
=$000246				CPUX             = $000246 ;2 Bytes X Register (X)
=$000248				CPUY             = $000248 ;2 Bytes Y Register (Y)
=$00024a				CPUSTACK         = $00024A ;2 Bytes Stack Pointer (S)
=$00024c				CPUDP            = $00024C ;2 Bytes Direct Page Register (D)
=$00024e				CPUDBR           = $00024E ;1 Byte  Data Bank Register (B)
=$00024f				CPUFLAGS         = $00024F ;1 Byte  Flags (P)
=$000250				MONITOR_VARS     = $000250 ; Byte  MONITOR Variables. BASIC variables may overlap this space
=$000250				MCMDADDR         = $000250 ;3 Bytes Address of the current line of text being processed by the command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
=$000253				MCMP_TEXT        = $000253 ;3 Bytes Address of symbol being evaluated for COMPARE routine
=$000256				MCMP_LEN         = $000256 ;2 Bytes Length of symbol being evaluated for COMPARE routine
=$000258				MCMD             = $000258 ;3 Bytes Address of the current command/function string
=$00025b				MCMD_LEN         = $00025B ;2 Bytes Length of the current command/function string
=$00025d				MARG1            = $00025D ;4 Bytes First command argument. May be data or address, depending on command
=$000261				MARG2            = $000261 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000265				MARG3            = $000265 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000269				MARG4            = $000269 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$00026d				MARG5            = $00026D ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000271				MARG6            = $000271 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000275				MARG7            = $000275 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000279				MARG8            = $000279 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000300				LOADFILE_VARS    = $000300 ; Byte
=$000300				LOADFILE_NAME    = $000300 ;3 Bytes (addr) Name of file to load. Address in Data Page
=$000303				LOADFILE_LEN     = $000303 ;1 Byte  Length of filename. 0=Null Terminated
=$000304				LOADPBR          = $000304 ;1 Byte  First Program Bank of loaded file ($05 segment)
=$000305				LOADPC           = $000305 ;2 Bytes Start address of loaded file ($05 segment)
=$000307				LOADDBR          = $000307 ;1 Byte  First data bank of loaded file ($06 segment)
=$000308				LOADADDR         = $000308 ;2 Bytes FIrst data address of loaded file ($06 segment)
=$00030a				LOADFILE_TYPE    = $00030A ;3 Bytes (addr) File type string in loaded data file. Actual string data will be in Bank 1. Valid values are BIN, PRG, P16
=$00030d				BLOCK_LEN        = $00030D ;2 Bytes Length of block being loaded
=$00030f				BLOCK_ADDR       = $00030F ;2 Bytes (temp) Address of block being loaded
=$000311				BLOCK_BANK       = $000311 ;1 Byte  (temp) Bank of block being loaded
=$000312				BLOCK_COUNT      = $000312 ;2 Bytes (temp) Counter of bytes read as file is loaded
=$000320				SDOS_BLOCK_BEGIN = $000320 ;
=$000324				SDOS_LOAD_ADDY   = $000324 ; 4 Bytes (Uses 3 Only)
=$000328				SDOS_FILE_SIZE   = $000328 ;
=$00032c				SDOS_BYTE_NUMBER = $00032C ; Number of Byte to Read or Write before changing the Pointer
=$000330				SDOS_REG_WR32_AD = $000330 ; 4 Bytes (Used to read and Write Values in/from CH376S)
=$000334				SDOS_BYTE_PTR    = $000334
=$000380				SDOS_FILE_NAME   = $000380 ; // Max of 128 Chars
=$000400				SDOS_BLK_BEGIN   = $000400 ; 512 Bytes to Store SD Card Incoming or Outcoming Block
=$0006ff				SDOS_BLK_END     = $0006FF ;
=$000f00				KEY_BUFFER       = $000F00 ;64 Bytes keyboard buffer
=$0080					KEY_BUFFER_SIZE  = $0080 ;128 Bytes (constant) keyboard buffer length
=$000f00				MOUSE_BUTTONS_REG= $000F00 ; bit 2=middle, bit 1=right, bit 0=left
=$000f7f				KEY_BUFFER_END   = $000F7F ;1 Byte  Last byte of keyboard buffer
=$000f83				KEY_BUFFER_CMD   = $000F83 ;1 Byte  Indicates the Command Process Status
=$000f84				COMMAND_SIZE_STR = $000F84 ; 1 Byte
=$000f86				COMMAND_COMP_TMP = $000F86 ; 2 Bytes
=$000f87				KEYBOARD_SC_FLG  = $000F87 ;1 Bytes that indicate the Status of Left Shift, Left CTRL, Left ALT, Right Shift
=$000f88				KEYBOARD_SC_TMP  = $000F88 ;1 Byte, Interrupt Save Scan Code while Processing
=$001000				TEST_BEGIN       = $001000 ;28672 Bytes Test/diagnostic code for prototype.
=$007fff				TEST_END         = $007FFF ;0 Byte
=$008000				STACK_BEGIN      = $008000 ;32512 Bytes The default beginning of stack space
=$00feff				STACK_END        = $00FEFF ;0 Byte  End of stack space. Everything below this is I/O space
=$18ff00				ISR_BEGIN        = $18FF00 ; Byte  Beginning of CPU vectors in Direct page
=$18ff00				HRESET           = $18FF00 ;16 Bytes Handle RESET asserted. Reboot computer and re-initialize the kernel.
=$18ff10				HCOP             = $18FF10 ;16 Bytes Handle the COP instruction. Program use; not used by OS
=$18ff20				HBRK             = $18FF20 ;16 Bytes Handle the BRK instruction. Returns to BASIC Ready prompt.
=$18ff30				HABORT           = $18FF30 ;16 Bytes Handle ABORT asserted. Return to Ready prompt with an error message.
=$18ff40				HNMI             = $18FF40 ;32 Bytes Handle NMI
=$18ff60				HIRQ             = $18FF60 ;32 Bytes Handle IRQ
=$18ff80				Unused_FF80      = $18FF80 ;End of direct page Interrrupt handlers
=$18ffe0				VECTORS_BEGIN    = $18FFE0 ;0 Byte  Interrupt vectors
=$00ffe0				JMP_READY        = $00FFE0 ;4 Bytes Jumps to ROM READY routine. Modified whenever alternate command interpreter is loaded.
=$00ffe4				VECTOR_COP       = $00FFE4 ;2 Bytes Native COP Interrupt vector
=$00ffe6				VECTOR_BRK       = $00FFE6 ;2 Bytes Native BRK Interrupt vector
=$00ffe8				VECTOR_ABORT     = $00FFE8 ;2 Bytes Native ABORT Interrupt vector
=$00ffea				VECTOR_NMI       = $00FFEA ;2 Bytes Native NMI Interrupt vector
=$00ffec				VECTOR_RESET     = $00FFEC ;2 Bytes Unused (Native RESET vector)
=$00ffee				VECTOR_IRQ       = $00FFEE ;2 Bytes Native IRQ Vector
=$00fff0				RETURN           = $00FFF0 ;4 Bytes RETURN key handler. Points to BASIC or MONITOR subroutine to execute when RETURN is pressed.
=$00fff4				VECTOR_ECOP      = $00FFF4 ;2 Bytes Emulation mode interrupt handler
=$00fff6				VECTOR_EBRK      = $00FFF6 ;2 Bytes Emulation mode interrupt handler
=$00fff8				VECTOR_EABORT    = $00FFF8 ;2 Bytes Emulation mode interrupt handler
=$00fffa				VECTOR_ENMI      = $00FFFA ;2 Bytes Emulation mode interrupt handler
=$00fffc				VECTOR_ERESET    = $00FFFC ;2 Bytes Emulation mode interrupt handler
=$00fffe				VECTOR_EIRQ      = $00FFFE ;2 Bytes Emulation mode interrupt handler
=$200000				VECTORS_END      = $200000 ;*End of vector space
=$00ffff				BANK0_END        = $00FFFF ;End of Bank 00 and Direct page

;******  Return to file: matrix.asm


;******  Processing file: vicky_def.asm

=$af0000				MASTER_CTRL_REG_L	      = $AF0000
=$01					Mstr_Ctrl_Text_Mode_En  = $01       ; Enable the Text Mode
=$02					Mstr_Ctrl_Text_Overlay  = $02       ; Enable the Overlay of the text mode on top of Graphic Mode (the Background Color is ignored)
=$04					Mstr_Ctrl_Graph_Mode_En = $04       ; Enable the Graphic Mode
=$08					Mstr_Ctrl_Bitmap_En     = $08       ; Enable the Bitmap Module In Vicky
=$10					Mstr_Ctrl_TileMap_En    = $10       ; Enable the Tile Module in Vicky
=$20					Mstr_Ctrl_Sprite_En     = $20       ; Enable the Sprite Module in Vicky
=$40					Mstr_Ctrl_GAMMA_En      = $40       ; this Enable the GAMMA correction - The Analog and DVI have different color value, the GAMMA is great to correct the difference
=$80					Mstr_Ctrl_Disable_Vid   = $80       ; This will disable the Scanning of the Video hence giving 100% bandwith to the CPU
=$af0001				MASTER_CTRL_REG_H	      = $AF0001
=$af0002				VKY_RESERVED_00         = $AF0002
=$af0003				VKY_RESERVED_01         = $AF0003
=$af0004				BORDER_CTRL_REG         = $AF0004   ; Bit[0] - Enable (1 by default)  Bit[4..6]: X Scroll Offset ( Will scroll Left) (Acceptable Value: 0..7)
=$01					Border_Ctrl_Enable      = $01
=$af0005				BORDER_COLOR_B          = $AF0005
=$af0006				BORDER_COLOR_G          = $AF0006
=$af0007				BORDER_COLOR_R          = $AF0007
=$af0008				BORDER_X_SIZE           = $AF0008   ; X-  Values: 0 - 32 (Default: 32)
=$af0009				BORDER_Y_SIZE           = $AF0009   ; Y- Values 0 -32 (Default: 32)
=$af000d				BACKGROUND_COLOR_B      = $AF000D ; When in Graphic Mode, if a pixel is "0" then the Background pixel is chosen
=$af000e				BACKGROUND_COLOR_G      = $AF000E
=$af000f				BACKGROUND_COLOR_R      = $AF000F ;
=$af0010				VKY_TXT_CURSOR_CTRL_REG = $AF0010   ;[0]  Enable Text Mode
=$01					Vky_Cursor_Enable       = $01
=$02					Vky_Cursor_Flash_Rate0  = $02
=$04					Vky_Cursor_Flash_Rate1  = $04
=$08					Vky_Cursor_FONT_Page0   = $08       ; Pick Font Page 0 or Font Page 1
=$10					Vky_Cursor_FONT_Page1   = $10       ; Pick Font Page 0 or Font Page 1
=$af0011				VKY_TXT_RESERVED        = $AF0011   ;Not in Use
=$af0012				VKY_TXT_CURSOR_CHAR_REG = $AF0012
=$af0013				VKY_TXT_CURSOR_COLR_REG = $AF0013
=$af0014				VKY_TXT_CURSOR_X_REG_L  = $AF0014
=$af0015				VKY_TXT_CURSOR_X_REG_H  = $AF0015
=$af0016				VKY_TXT_CURSOR_Y_REG_L  = $AF0016
=$af0017				VKY_TXT_CURSOR_Y_REG_H  = $AF0017
=$af0018				TXT_CLR_START_DISPLAY_PTR = $AF0018  ; (0 to 255) (this Add a X Offset to the Display Start Address)
=$af001c				VKY_INFO_CHIP_NUM_L     = $AF001C
=$af001d				VKY_INFO_CHIP_NUM_H     = $AF001D
=$af001e				VKY_INFO_CHIP_VER_L     = $AF001E
=$af001f				VKY_INFO_CHIP_VER_H     = $AF001F
=$01					TILE_Enable             = $01
=$02					TILE_LUT0               = $02
=$04					TILE_LUT1               = $04
=$08					TILE_LUT2               = $08
=$80					TILESHEET_256x256_En    = $80   ; 0 -> Sequential, 1-> 256x256 Tile Sheet Striding
=$af0100				TL0_CONTROL_REG         = $AF0100       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0101				TL0_START_ADDY_L        = $AF0101       ; Not USed right now - Starting Address to where is the MAP
=$af0102				TL0_START_ADDY_M        = $AF0102
=$af0103				TL0_START_ADDY_H        = $AF0103
=$af0104				TL0_MAP_X_STRIDE_L      = $AF0104       ; The Stride of the Map
=$af0105				TL0_MAP_X_STRIDE_H      = $AF0105
=$af0106				TL0_MAP_Y_STRIDE_L      = $AF0106       ; The Stride of the Map
=$af0107				TL0_MAP_Y_STRIDE_H      = $AF0107
=$af0108				TL1_CONTROL_REG         = $AF0108       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0109				TL1_START_ADDY_L        = $AF0109       ; Not USed right now - Starting Address to where is the MAP
=$af010a				TL1_START_ADDY_M        = $AF010A
=$af010b				TL1_START_ADDY_H        = $AF010B
=$af010c				TL1_MAP_X_STRIDE_L      = $AF010C       ; The Stride of the Map
=$af010d				TL1_MAP_X_STRIDE_H      = $AF010D
=$af010e				TL1_MAP_Y_STRIDE_L      = $AF010E       ; The Stride of the Map
=$af010f				TL1_MAP_Y_STRIDE_H      = $AF010F
=$af0110				TL2_CONTROL_REG         = $AF0110       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0111				TL2_START_ADDY_L        = $AF0111       ; Not USed right now - Starting Address to where is the MAP
=$af0112				TL2_START_ADDY_M        = $AF0112
=$af0113				TL2_START_ADDY_H        = $AF0113
=$af0114				TL2_MAP_X_STRIDE_L      = $AF0114       ; The Stride of the Map
=$af0115				TL2_MAP_X_STRIDE_H      = $AF0115
=$af0116				TL2_MAP_Y_STRIDE_L      = $AF0116       ; The Stride of the Map
=$af0117				TL2_MAP_Y_STRIDE_H      = $AF0117
=$af0118				TL3_CONTROL_REG         = $AF0118       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0119				TL3_START_ADDY_L        = $AF0119       ; Not USed right now - Starting Address to where is the MAP
=$af011a				TL3_START_ADDY_M        = $AF011A
=$af011b				TL3_START_ADDY_H        = $AF011B
=$af011c				TL3_MAP_X_STRIDE_L      = $AF011C       ; The Stride of the Map
=$af011d				TL3_MAP_X_STRIDE_H      = $AF011D
=$af011e				TL3_MAP_Y_STRIDE_L      = $AF011E       ; The Stride of the Map
=$af011f				TL3_MAP_Y_STRIDE_H      = $AF011F
=$af0140				BM_CONTROL_REG          = $AF0140
=$af0141				BM_START_ADDY_L         = $AF0141
=$af0142				BM_START_ADDY_M         = $AF0142
=$af0143				BM_START_ADDY_H         = $AF0143
=$af0144				BM_X_SIZE_L             = $AF0144
=$af0145				BM_X_SIZE_H             = $AF0145
=$af0146				BM_Y_SIZE_L             = $AF0146
=$af0147				BM_Y_SIZE_H             = $AF0147
=$af0148				BM_RESERVED_0           = $AF0148
=$af0149				BM_RESERVED_1           = $AF0149
=$af014a				BM_RESERVED_2           = $AF014A
=$af014b				BM_RESERVED_3           = $AF014B
=$af014c				BM_RESERVED_4           = $AF014C
=$af014d				BM_RESERVED_5           = $AF014D
=$af014e				BM_RESERVED_6           = $AF014E
=$af014f				BM_RESERVED_7           = $AF014F
=$01					SPRITE_Enable             = $01
=$02					SPRITE_LUT0               = $02 ; This is the LUT that the Sprite will use
=$04					SPRITE_LUT1               = $04
=$08					SPRITE_LUT2               = $08 ; Only 4 LUT for Now, So this bit is not used.
=$10					SPRITE_DEPTH0             = $10 ; This is the Layer the Sprite will be Displayed in
=$20					SPRITE_DEPTH1             = $20
=$40					SPRITE_DEPTH2             = $40
=$af0200				SP00_CONTROL_REG        = $AF0200
=$af0201				SP00_ADDY_PTR_L         = $AF0201
=$af0202				SP00_ADDY_PTR_M         = $AF0202
=$af0203				SP00_ADDY_PTR_H         = $AF0203
=$af0204				SP00_X_POS_L            = $AF0204
=$af0205				SP00_X_POS_H            = $AF0205
=$af0206				SP00_Y_POS_L            = $AF0206
=$af0207				SP00_Y_POS_H            = $AF0207
=$af0208				SP01_CONTROL_REG        = $AF0208
=$af0209				SP01_ADDY_PTR_L         = $AF0209
=$af020a				SP01_ADDY_PTR_M         = $AF020A
=$af020b				SP01_ADDY_PTR_H         = $AF020B
=$af020c				SP01_X_POS_L            = $AF020C
=$af020d				SP01_X_POS_H            = $AF020D
=$af020e				SP01_Y_POS_L            = $AF020E
=$af020f				SP01_Y_POS_H            = $AF020F
=$af0210				SP02_CONTROL_REG        = $AF0210
=$af0211				SP02_ADDY_PTR_L         = $AF0211
=$af0212				SP02_ADDY_PTR_M         = $AF0212
=$af0213				SP02_ADDY_PTR_H         = $AF0213
=$af0214				SP02_X_POS_L            = $AF0214
=$af0215				SP02_X_POS_H            = $AF0215
=$af0216				SP02_Y_POS_L            = $AF0216
=$af0217				SP02_Y_POS_H            = $AF0217
=$af0218				SP03_CONTROL_REG        = $AF0218
=$af0219				SP03_ADDY_PTR_L         = $AF0219
=$af021a				SP03_ADDY_PTR_M         = $AF021A
=$af021b				SP03_ADDY_PTR_H         = $AF021B
=$af021c				SP03_X_POS_L            = $AF021C
=$af021d				SP03_X_POS_H            = $AF021D
=$af021e				SP03_Y_POS_L            = $AF021E
=$af021f				SP03_Y_POS_H            = $AF021F
=$af0220				SP04_CONTROL_REG        = $AF0220
=$af0221				SP04_ADDY_PTR_L         = $AF0221
=$af0222				SP04_ADDY_PTR_M         = $AF0222
=$af0223				SP04_ADDY_PTR_H         = $AF0223
=$af0224				SP04_X_POS_L            = $AF0224
=$af0225				SP04_X_POS_H            = $AF0225
=$af0226				SP04_Y_POS_L            = $AF0226
=$af0227				SP04_Y_POS_H            = $AF0227
=$af0228				SP05_CONTROL_REG        = $AF0228
=$af0229				SP05_ADDY_PTR_L         = $AF0229
=$af022a				SP05_ADDY_PTR_M         = $AF022A
=$af022b				SP05_ADDY_PTR_H         = $AF022B
=$af022c				SP05_X_POS_L            = $AF022C
=$af022d				SP05_X_POS_H            = $AF022D
=$af022e				SP05_Y_POS_L            = $AF022E
=$af022f				SP05_Y_POS_H            = $AF022F
=$af0230				SP06_CONTROL_REG        = $AF0230
=$af0231				SP06_ADDY_PTR_L         = $AF0231
=$af0232				SP06_ADDY_PTR_M         = $AF0232
=$af0233				SP06_ADDY_PTR_H         = $AF0233
=$af0234				SP06_X_POS_L            = $AF0234
=$af0235				SP06_X_POS_H            = $AF0235
=$af0236				SP06_Y_POS_L            = $AF0236
=$af0237				SP06_Y_POS_H            = $AF0237
=$af0238				SP07_CONTROL_REG        = $AF0238
=$af0239				SP07_ADDY_PTR_L         = $AF0239
=$af023a				SP07_ADDY_PTR_M         = $AF023A
=$af023b				SP07_ADDY_PTR_H         = $AF023B
=$af023c				SP07_X_POS_L            = $AF023C
=$af023d				SP07_X_POS_H            = $AF023D
=$af023e				SP07_Y_POS_L            = $AF023E
=$af023f				SP07_Y_POS_H            = $AF023F
=$af0240				SP08_CONTROL_REG        = $AF0240
=$af0241				SP08_ADDY_PTR_L         = $AF0241
=$af0242				SP08_ADDY_PTR_M         = $AF0242
=$af0243				SP08_ADDY_PTR_H         = $AF0243
=$af0244				SP08_X_POS_L            = $AF0244
=$af0245				SP08_X_POS_H            = $AF0245
=$af0246				SP08_Y_POS_L            = $AF0246
=$af0247				SP08_Y_POS_H            = $AF0247
=$af0248				SP09_CONTROL_REG        = $AF0248
=$af0249				SP09_ADDY_PTR_L         = $AF0249
=$af024a				SP09_ADDY_PTR_M         = $AF024A
=$af024b				SP09_ADDY_PTR_H         = $AF024B
=$af024c				SP09_X_POS_L            = $AF024C
=$af024d				SP09_X_POS_H            = $AF024D
=$af024e				SP09_Y_POS_L            = $AF024E
=$af024f				SP09_Y_POS_H            = $AF024F
=$af0250				SP10_CONTROL_REG        = $AF0250
=$af0251				SP10_ADDY_PTR_L         = $AF0251
=$af0252				SP10_ADDY_PTR_M         = $AF0252
=$af0253				SP10_ADDY_PTR_H         = $AF0253
=$af0254				SP10_X_POS_L            = $AF0254
=$af0255				SP10_X_POS_H            = $AF0255
=$af0256				SP10_Y_POS_L            = $AF0256
=$af0257				SP10_Y_POS_H            = $AF0257
=$af0258				SP11_CONTROL_REG        = $AF0258
=$af0259				SP11_ADDY_PTR_L         = $AF0259
=$af025a				SP11_ADDY_PTR_M         = $AF025A
=$af025b				SP11_ADDY_PTR_H         = $AF025B
=$af025c				SP11_X_POS_L            = $AF025C
=$af025d				SP11_X_POS_H            = $AF025D
=$af025e				SP11_Y_POS_L            = $AF025E
=$af025f				SP11_Y_POS_H            = $AF025F
=$af0260				SP12_CONTROL_REG        = $AF0260
=$af0261				SP12_ADDY_PTR_L         = $AF0261
=$af0262				SP12_ADDY_PTR_M         = $AF0262
=$af0263				SP12_ADDY_PTR_H         = $AF0263
=$af0264				SP12_X_POS_L            = $AF0264
=$af0265				SP12_X_POS_H            = $AF0265
=$af0266				SP12_Y_POS_L            = $AF0266
=$af0267				SP12_Y_POS_H            = $AF0267
=$af0268				SP13_CONTROL_REG        = $AF0268
=$af0269				SP13_ADDY_PTR_L         = $AF0269
=$af026a				SP13_ADDY_PTR_M         = $AF026A
=$af026b				SP13_ADDY_PTR_H         = $AF026B
=$af026c				SP13_X_POS_L            = $AF026C
=$af026d				SP13_X_POS_H            = $AF026D
=$af026e				SP13_Y_POS_L            = $AF026E
=$af026f				SP13_Y_POS_H            = $AF026F
=$af0270				SP14_CONTROL_REG        = $AF0270
=$af0271				SP14_ADDY_PTR_L         = $AF0271
=$af0272				SP14_ADDY_PTR_M         = $AF0272
=$af0273				SP14_ADDY_PTR_H         = $AF0273
=$af0274				SP14_X_POS_L            = $AF0274
=$af0275				SP14_X_POS_H            = $AF0275
=$af0276				SP14_Y_POS_L            = $AF0276
=$af0277				SP14_Y_POS_H            = $AF0277
=$af0278				SP15_CONTROL_REG        = $AF0278
=$af0279				SP15_ADDY_PTR_L         = $AF0279
=$af027a				SP15_ADDY_PTR_M         = $AF027A
=$af027b				SP15_ADDY_PTR_H         = $AF027B
=$af027c				SP15_X_POS_L            = $AF027C
=$af027d				SP15_X_POS_H            = $AF027D
=$af027e				SP15_Y_POS_L            = $AF027E
=$af027f				SP15_Y_POS_H            = $AF027F
=$af0280				SP16_CONTROL_REG        = $AF0280
=$af0281				SP16_ADDY_PTR_L         = $AF0281
=$af0282				SP16_ADDY_PTR_M         = $AF0282
=$af0283				SP16_ADDY_PTR_H         = $AF0283
=$af0284				SP16_X_POS_L            = $AF0284
=$af0285				SP16_X_POS_H            = $AF0285
=$af0286				SP16_Y_POS_L            = $AF0286
=$af0287				SP16_Y_POS_H            = $AF0287
=$af0288				SP17_CONTROL_REG        = $AF0288
=$af0289				SP17_ADDY_PTR_L         = $AF0289
=$af028a				SP17_ADDY_PTR_M         = $AF028A
=$af028b				SP17_ADDY_PTR_H         = $AF028B
=$af028c				SP17_X_POS_L            = $AF028C
=$af028d				SP17_X_POS_H            = $AF028D
=$af028e				SP17_Y_POS_L            = $AF028E
=$af028f				SP17_Y_POS_H            = $AF028F
=$af0400				VDMA_CONTROL_REG        = $AF0400
=$01					VDMA_CTRL_Enable        = $01
=$02					VDMA_CTRL_1D_2D         = $02     ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					VDMA_CTRL_TRF_Fill      = $04     ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					VDMA_CTRL_Int_Enable    = $08     ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$80					VDMA_CTRL_Start_TRF     = $80     ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$af0401				VDMA_BYTE_2_WRITE       = $AF0401 ; Write Only - Byte to Write in the Fill Function
=$af0401				VDMA_STATUS_REG         = $AF0401 ; Read only
=$01					VDMA_STAT_Size_Err      = $01     ; If Set to 1, Overall Size is Invalid
=$02					VDMA_STAT_Dst_Add_Err   = $02     ; If Set to 1, Destination Address Invalid
=$04					VDMA_STAT_Src_Add_Err   = $04     ; If Set to 1, Source Address Invalid
=$80					VDMA_STAT_VDMA_IPS      = $80     ; If Set to 1, VDMA Transfer in Progress (this Inhibit CPU Access to Mem)
=$af0402				VDMA_SRC_ADDY_L         = $AF0402 ; Pointer to the Source of the Data to be stransfered
=$af0403				VDMA_SRC_ADDY_M         = $AF0403 ; This needs to be within Vicky's Range ($00_0000 - $3F_0000)
=$af0404				VDMA_SRC_ADDY_H         = $AF0404
=$af0405				VDMA_DST_ADDY_L         = $AF0405 ; Destination Pointer within Vicky's video memory Range
=$af0406				VDMA_DST_ADDY_M        = $AF0406 ; ($00_0000 - $3F_0000)
=$af0407				VDMA_DST_ADDY_H         = $AF0407
=$af0408				VDMA_SIZE_L             = $AF0408 ; Maximum Value: $40:0000 (4Megs)
=$af0409				VDMA_SIZE_M             = $AF0409
=$af040a				VDMA_SIZE_H             = $AF040A
=$af040b				VDMA_IGNORED            = $AF040B
=$af0408				VDMA_X_SIZE_L           = $AF0408 ; Maximum Value: 65535
=$af0409				VDMA_X_SIZE_H           = $AF0409
=$af040a				VDMA_Y_SIZE_L           = $AF040A ; Maximum Value: 65535
=$af040b				VDMA_Y_SIZE_H           = $AF040B
=$af040c				VDMA_SRC_STRIDE_L       = $AF040C ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040d				VDMA_SRC_STRIDE_H       = $AF040D ;
=$af040e				VDMA_DST_STRIDE_L       = $AF040E ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040f				VDMA_DST_STRIDE_H       = $AF040F ;
=$af0500				MOUSE_PTR_GRAP0_START    = $AF0500 ; 16 x 16 = 256 Pixels (Grey Scale) 0 = Transparent, 1 = Black , 255 = White
=$af05ff				MOUSE_PTR_GRAP0_END      = $AF05FF ; Pointer 0
=$af0600				MOUSE_PTR_GRAP1_START    = $AF0600 ;
=$af06ff				MOUSE_PTR_GRAP1_END      = $AF06FF ; Pointer 1
=$af0700				MOUSE_PTR_CTRL_REG_L    = $AF0700 ; Bit[0] Enable, Bit[1] = 0  ( 0 = Pointer0, 1 = Pointer1)
=$af0701				MOUSE_PTR_CTRL_REG_H    = $AF0701 ;
=$af0702				MOUSE_PTR_X_POS_L       = $AF0702 ; X Position (0 - 639) (Can only read now) Writing will have no effect
=$af0703				MOUSE_PTR_X_POS_H       = $AF0703 ;
=$af0704				MOUSE_PTR_Y_POS_L       = $AF0704 ; Y Position (0 - 479) (Can only read now) Writing will have no effect
=$af0705				MOUSE_PTR_Y_POS_H       = $AF0705 ;
=$af0706				MOUSE_PTR_BYTE0         = $AF0706 ; Byte 0 of Mouse Packet (you must write 3 Bytes)
=$af0707				MOUSE_PTR_BYTE1         = $AF0707 ; Byte 1 of Mouse Packet (if you don't, then )
=$af0708				MOUSE_PTR_BYTE2         = $AF0708 ; Byte 2 of Mouse Packet (state Machine will be jammed in 1 state)
=$af070b				C256F_MODEL_MAJOR       = $AF070B ;
=$af070c				C256F_MODEL_MINOR       = $AF070C ;
=$af070d				FPGA_DOR                = $AF070D ;
=$af070e				FPGA_MOR                = $AF070E ;
=$af070f				FPGA_YOR                = $AF070F ;
=$af1f40				FG_CHAR_LUT_PTR         = $AF1F40
=$af1f80				BG_CHAR_LUT_PTR		      = $AF1F80
=$af2000				GRPH_LUT0_PTR		        = $AF2000
=$af2400				GRPH_LUT1_PTR		        = $AF2400
=$af2800				GRPH_LUT2_PTR		        = $AF2800
=$af2c00				GRPH_LUT3_PTR		        = $AF2C00
=$af3000				GRPH_LUT4_PTR		        = $AF3000
=$af3400				GRPH_LUT5_PTR		        = $AF3400
=$af3800				GRPH_LUT6_PTR		        = $AF3800
=$af3c00				GRPH_LUT7_PTR		        = $AF3C00
=$af4000				GAMMA_B_LUT_PTR		      = $AF4000
=$af4100				GAMMA_G_LUT_PTR		      = $AF4100
=$af4200				GAMMA_R_LUT_PTR		      = $AF4200
=$af5000				TILE_MAP0       		    = $AF5000     ;$AF5000 - $AF57FF
=$af5800				TILE_MAP1               = $AF5800     ;$AF5800 - $AF5FFF
=$af6000				TILE_MAP2               = $AF6000     ;$AF6000 - $AF67FF
=$af6800				TILE_MAP3               = $AF6800     ;$AF6800 - $AF6FFF
=$af8000				FONT_MEMORY_BANK0       = $AF8000     ;$AF8000 - $AF87FF
=$af8800				FONT_MEMORY_BANK1       = $AF8800     ;$AF8800 - $AF8FFF
=$afa000				CS_TEXT_MEM_PTR         = $AFA000
=$afc000				CS_COLOR_MEM_PTR        = $AFC000
=$afe000				BTX_START               = $AFE000     ; BEATRIX Registers
=$afffff				BTX_END                 = $AFFFFF

;******  Return to file: matrix.asm

=$1900a8				CLRSCREEN	= $1900a8
=$1904ed				ENDLESS_LOOP	= $1904ed ; so lame, but works for testing...
=803					RAND_SIZE	= 803
.030000	18		clc				clc			; switch to native
.030001	fb		xce				xce			;
.030002	0b		phd				phd
.030003	08		php				php
.030004	c2 30		rep #$30	                REP #$30        ; set A&X long
.030006	48		pha				pha
.030007	da		phx				phx
.030008	22 22 00 03	jsl $030022			jsl ICLRSCREEN2
.03000c	22 26 01 03	jsl $030126			jsl TBOX_INIT		; init line offsets
.030010	22 41 01 03	jsl $030141			jsl INIT_LUT
.030014	22 4f 00 03	jsl $03004f			jsl MATRIX_PRINT
.030018	c2 20		rep #$20	                REP #$20        ; set A long
.03001a	fa		plx				plx
.03001b	68		pla				pla
.03001c	28		plp				plp
.03001d	2b		pld				pld
.03001e	5c ed 04 19	jmp $1904ed			jmp ENDLESS_LOOP
.030022	0b		phd		ICLRSCREEN2	PHD
.030023	08		php				PHP
.030024	c2 30		rep #$30	                REP #$30        ; set A&X long
.030026	48		pha				PHA
.030027	da		phx				PHX
.030028	e2 20		sep #$20	                SEP #$20        ; set A short
.03002a	a2 00 00	ldx #$0000			LDX #$0000		; Only Use One Pointer
.03002d	a9 20		lda #$20			LDA #$20		; Fill the Entire Screen with Space
.03002f	9f 00 a0 af	sta $afa000,x	iclearprint_text	 STA CS_TEXT_MEM_PTR, x  ;
.030033	e8		inx				INX
.030034	e0 00 20	cpx #$2000			CPX #$2000
.030037	d0 f6		bne $03002f			BNE iclearprint_text
.030039	a2 00 00	ldx #$0000			LDX #$0000		; Only Use One Pointer
.03003c	a9 11		lda #$11			LDA #$11		; Fill the Color Memory with Foreground: 75% Purple, Background 12.5% White
.03003e	9f 00 c0 af	sta $afc000,x	iclearloop1	 STA CS_COLOR_MEM_PTR, x ;
.030042	e8		inx				INX
.030043	e0 00 20	cpx #$2000			CPX #$2000
.030046	d0 f6		bne $03003e			BNE iclearloop1
.030048	c2 20		rep #$20	                REP #$20        ; set A long
.03004a	fa		plx				PLX
.03004b	68		pla				PLA
.03004c	28		plp				PLP
.03004d	2b		pld				PLD
.03004e	6b		rtl				RTL
.00e0					matrix
>00e0					counter		.word ? ;
>00e2					rnd_pos		.word ?	; for displaying characters
>00e4					rnd2_pos	.word ?	; for new rain chance
>00e6					row_current     .word ? ;
>00e8					delay_counter	.word ? ;
.03004f	ea		nop		MATRIX_PRINT	nop
.030050	c2 20		rep #$20	                REP #$20        ; set A long
.030052	a9 22 03	lda #$0322			lda #RAND_SIZE-1
.030055	85 e2		sta $e2				sta matrix.rnd_pos
.030057	85 e4		sta $e4				sta matrix.rnd2_pos
.030059	a9 00 08	lda #$0800			lda #2048		; how many iterations?
.03005c	85 e0		sta $e0				sta matrix.counter
.03005e	a5 13		lda $13				lda LINES_VISIBLE
.030060	3a		dec a				dec a			; assume that LINES_VISIBLE > 0
.030061	85 e6		sta $e6				sta matrix.row_current
.030063	c2 30		rep #$30	                REP #$30        ; set A&X long
.030065	a5 e6		lda $e6		print_text	lda matrix.row_current
.030067	0a		asl a				asl a			; because we have array of words
.030068	aa		tax				tax
.030069	bf a0 01 03	lda $0301a0,x			lda line_offset, x
.03006d	18		clc				clc
.03006e	65 0f		adc $0f				adc COLS_VISIBLE
.030070	aa		tax				tax
.030071	e2 20		sep #$20	                SEP #$20        ; set A short
.030073	a4 0f		ldy $0f				ldy COLS_VISIBLE
.030075	ea		nop		put_char	nop
.030076	20 04 01	jsr $030104			jsr GET_RAND
.030079	9f 00 a0 af	sta $afa000,x			sta CS_TEXT_MEM_PTR, x
.03007d	ca		dex				dex
.03007e	88		dey				dey
.03007f	10 f4		bpl $030075			bpl put_char
.030081	ea		nop		next_line	nop
.030082	c2 30		rep #$30	                REP #$30        ; set A&X long
.030084	a5 e6		lda $e6				lda matrix.row_current
.030086	3a		dec a				dec a
.030087	85 e6		sta $e6				sta matrix.row_current
.030089	10 da		bpl $030065			bpl print_text
.03008b	ea		nop		text_done	nop
.03008c	e2 20		sep #$20	                SEP #$20        ; set A short
.03008e	c2 10		rep #$10	                REP #$10        ; set X long
.030090	a6 0f		ldx $0f				ldx COLS_VISIBLE
.030092	20 15 01	jsr $030115	line0		jsr GET_RAND2
.030095	c9 03		cmp #$03			cmp #3			; 2% chance
.030097	b0 06		bcs $03009f			bcs line1
.030099	a9 f1		lda #$f1			lda #$f1
.03009b	9f 00 c0 af	sta $afc000,x			sta CS_COLOR_MEM_PTR, x
.03009f	ca		dex		line1		dex
.0300a0	10 f0		bpl $030092			bpl line0
.0300a2	c2 20		rep #$20	                REP #$20        ; set A long
.0300a4	a5 13		lda $13		matrix_preloop	lda LINES_VISIBLE
.0300a6	3a		dec a				dec a			; assume that LINES_VISIBLE >= 2
.0300a7	3a		dec a				dec a			; assume that LINES_VISIBLE >= 2
.0300a8	85 e6		sta $e6				sta matrix.row_current
.0300aa	a5 e6		lda $e6		matrix_loop	lda matrix.row_current
.0300ac	0a		asl a				asl a			; because we have array of words
.0300ad	aa		tax				tax
.0300ae	bf a0 01 03	lda $0301a0,x			lda line_offset, x
.0300b2	18		clc				clc
.0300b3	65 0f		adc $0f				adc COLS_VISIBLE
.0300b5	aa		tax				tax
.0300b6	e2 20		sep #$20	                SEP #$20        ; set A short
.0300b8	a4 0f		ldy $0f				ldy COLS_VISIBLE
.0300ba	ea		nop		move0		nop
.0300bb	bf 00 c0 af	lda $afc000,x			lda CS_COLOR_MEM_PTR, x
.0300bf	29 f0		and #$f0			and #$f0
.0300c1	d0 09		bne $0300cc			bne move2
.0300c3	09 11		ora #$11			ora #$11
.0300c5	9f 80 c0 af	sta $afc080,x			sta CS_COLOR_MEM_PTR+$80, x
.0300c9	4c e1 00	jmp $0300e1			jmp move1
.0300cc	09 01		ora #$01	move2		ora #$01
.0300ce	9f 80 c0 af	sta $afc080,x			sta CS_COLOR_MEM_PTR+$80, x
.0300d2	4a		lsr a				lsr a
.0300d3	4a		lsr a				lsr a
.0300d4	4a		lsr a				lsr a
.0300d5	4a		lsr a				lsr a
.0300d6	3a		dec a				dec a
.0300d7	0a		asl a				asl a
.0300d8	0a		asl a				asl a
.0300d9	0a		asl a				asl a
.0300da	0a		asl a				asl a
.0300db	09 01		ora #$01			ora #$01
.0300dd	9f 00 c0 af	sta $afc000,x			sta CS_COLOR_MEM_PTR, x
.0300e1	ca		dex		move1		dex
.0300e2	88		dey				dey
.0300e3	10 d5		bpl $0300ba			bpl move0
.0300e5	c2 30		rep #$30	                REP #$30        ; set A&X long
.0300e7	a5 e6		lda $e6				lda matrix.row_current
.0300e9	3a		dec a				dec a
.0300ea	85 e6		sta $e6				sta matrix.row_current
.0300ec	10 bc		bpl $0300aa			bpl matrix_loop
.0300ee	a9 00 00	lda #$0000			lda #$0000
.0300f1	85 e8		sta $e8				sta matrix.delay_counter
.0300f3	e6 e8		inc $e8		delay_loop	inc matrix.delay_counter
.0300f5	a5 e8		lda $e8				lda matrix.delay_counter
.0300f7	c9 00 80	cmp #$8000			cmp #$8000
.0300fa	90 f7		bcc $0300f3			bcc delay_loop
.0300fc	c6 e0		dec $e0				dec matrix.counter
.0300fe	f0 03		beq $030103			beq finish
.030100	4c 8b 00	jmp $03008b			jmp text_done
.030103	6b		rtl		finish		rtl
.030104	da		phx		GET_RAND	phx
.030105	a6 e2		ldx $e2				ldx matrix.rnd_pos
.030107	bf 20 02 03	lda $030220,x			lda rnd0,x
.03010b	ca		dex				dex
.03010c	10 03		bpl $030111			bpl get_rand_out
.03010e	a2 22 03	ldx #$0322			ldx #RAND_SIZE-1
.030111	86 e2		stx $e2		get_rand_out	stx matrix.rnd_pos
.030113	fa		plx				plx
.030114	60		rts				rts
.030115	da		phx		GET_RAND2	phx
.030116	a6 e4		ldx $e4				ldx matrix.rnd2_pos
.030118	bf 43 05 03	lda $030543,x			lda rnd1,x
.03011c	ca		dex				dex
.03011d	10 03		bpl $030122			bpl get_rand2_out
.03011f	a2 22 03	ldx #$0322			ldx #RAND_SIZE-1
.030122	86 e4		stx $e4		get_rand2_out	stx matrix.rnd2_pos
.030124	fa		plx				plx
.030125	60		rts				rts
.030126					TBOX_INIT
.030126	c2 30		rep #$30	                REP #$30        ; set A&X long
.030128	a5 15		lda $15				lda LINES_MAX
.03012a	0a		asl a				asl a			; *2 because X indexes a words
.03012b	aa		tax				tax
.03012c	a5 15		lda $15				lda LINES_MAX
.03012e	0a		asl a				asl a
.03012f	0a		asl a				asl a
.030130	0a		asl a				asl a
.030131	0a		asl a				asl a
.030132	0a		asl a				asl a
.030133	0a		asl a				asl a
.030134	0a		asl a				asl a			; in A: LINES_MAX*$80
.030135	38		sec		tinit0		sec
.030136	e5 11		sbc $11				sbc COLS_PER_LINE	; default 128 bytes
.030138	ca		dex				dex
.030139	ca		dex				dex
.03013a	9f a0 01 03	sta $0301a0,x			sta line_offset,x
.03013e	d0 f5		bne $030135			bne tinit0
.030140	6b		rtl				rtl
.030141	ea		nop		INIT_LUT	nop
.030142	e2 20		sep #$20	                SEP #$20        ; set A short
.030144	c2 10		rep #$10	                REP #$10        ; set X long
.030146	a2 00 00	ldx #$0000			ldx #0
.030149	bf 5c 01 03	lda $03015c,x	init_fg_lut	lda lut_fg_tbl, x
.03014d	9f 40 1f af	sta $af1f40,x			sta FG_CHAR_LUT_PTR, x
.030151	9f 80 1f af	sta $af1f80,x			sta BG_CHAR_LUT_PTR, x
.030155	e8		inx				inx
.030156	e0 40 00	cpx #$0040			cpx #$40
.030159	d0 ee		bne $030149			bne init_fg_lut
.03015b	6b		rtl				rtl
>03015c	00 1a 00 00			lut_fg_tbl	.byte $00, $1a, $00, $00
>030160	00 1a 00 00					.byte $00, $1a, $00, $00
>030164	00 33 00 00					.byte $00, $33, $00, $00
>030168	00 33 00 00					.byte $00, $33, $00, $00
>03016c	00 50 00 00					.byte $00, $50, $00, $00
>030170	00 61 00 00					.byte $00, $61, $00, $00
>030174	00 63 00 00					.byte $00, $63, $00, $00
>030178	00 63 00 00					.byte $00, $63, $00, $00
>03017c	00 67 00 00					.byte $00, $67, $00, $00
>030180	00 69 00 00					.byte $00, $69, $00, $00
>030184	00 79 00 00					.byte $00, $79, $00, $00
>030188	00 7a 00 00					.byte $00, $7a, $00, $00
>03018c	00 80 00 00					.byte $00, $80, $00, $00
>030190	00 8f 00 00					.byte $00, $8f, $00, $00
>030194	00 e6 00 00					.byte $00, $e6, $00, $00
>030198	cc ff cc 00					.byte $cc, $ff, $cc, $00
>03019c							.align $10			; waste of memory, but debugging is easier
>0301a0	fe fe fe fe fe fe fe fe		line_offset	.fill 64 * 2, $FE		; not possible to determine at compile time
>0301a8	fe fe fe fe fe fe fe fe fe fe fe fe fe fe fe fe
;	...repeated 6 times (96 bytes)...
>030218	fe fe fe fe fe fe fe fe
>030220							.align $10			; waste of memory, but debugging is easier
>030220	d2 bc 24 49 74 3b 52 56		rnd0		.byte random([256] x RAND_SIZE)
>030228	34 8d f5 b2 cf ad c5 65 52 ed 9a c3 7d 84 a2 59
>030238	46 6c 81 20 2c 33 b0 47 a0 f8 d8 e0 63 61 56 45
>030248	34 30 48 a1 7a 1e 8a 13 47 e9 3e 97 47 d3 7e f1
>030258	1b 1c d4 02 5b 22 cb e9 99 43 7c f3 84 c5 1e 02
>030268	9e 8c 2e 1f 65 d7 b4 d5 e8 e5 61 12 6b ab c8 05
>030278	49 3b a7 d9 9a 9c b1 87 bc 55 ce 85 52 0c ca 89
>030288	1b 02 93 2b ca 24 c2 73 5f b4 da 5f 91 62 73 b8
>030298	b6 64 df c9 e1 06 0d 1e 8e bd d4 1d 58 56 04 27
>0302a8	2c 17 65 6a 10 c1 de b6 f1 7f 5b 34 29 cf 87 8e
>0302b8	33 10 f8 76 0b 92 df 0f 4d b5 bc c2 38 26 ac 6e
>0302c8	bb af 00 33 ac f9 fc c9 ae 7b aa 25 9c f4 85 00
>0302d8	21 1e d2 5b 8e d8 fa a4 94 89 19 8a fa 6c 62 69
>0302e8	fe c9 09 c2 d1 50 21 db 69 a8 11 5b d1 26 14 a7
>0302f8	05 27 69 b4 6d 98 51 d4 ab b7 79 1a 30 81 67 61
>030308	c0 1f fa d2 33 92 94 3e bc 93 d0 49 ad 30 12 92
>030318	d3 36 e3 f5 b6 50 c6 44 53 5d e6 d6 3d 99 79 63
>030328	57 1f 21 fe ec 4e f2 fb 94 65 2b a1 43 a5 88 e7
>030338	7f aa 06 2b e9 9d 76 50 98 9a 91 9a f6 4a aa f2
>030348	e7 58 8e 04 7e e9 5f 19 bf 8a 80 88 19 c1 2b c3
>030358	c6 7b bb cc bf 72 cd e3 97 5b db 46 9d f7 94 4d
>030368	5c 81 eb 6c d6 aa 2f ae 89 c8 a1 5b 2c 79 38 73
>030378	27 c8 73 bf e7 6c a4 6a 7e d0 de 33 f7 75 50 49
>030388	13 e4 63 db d2 10 d3 34 7b 7f 0a 21 d7 60 7f 70
>030398	2b 5f 23 e7 2d 80 c6 b6 fb 3d bd f9 d5 01 78 15
>0303a8	40 b8 8a 8d c5 49 58 ca c2 ec 94 43 0d 5b 34 05
>0303b8	69 60 30 ac f7 1d 2e db 41 43 9b c2 a9 23 9b 89
>0303c8	20 f2 05 66 a2 49 da 54 27 f7 29 38 ac 34 eb 44
>0303d8	0d 40 54 bc 85 f0 cf f5 be 8f 89 14 03 3c 57 35
>0303e8	4e 03 1e 3f 62 b8 d6 d0 39 01 80 b9 40 72 83 6d
>0303f8	ad 0f b7 3c 79 00 18 2e 7f 96 0f 92 4d 81 e4 ad
>030408	8d 28 56 d9 94 54 2e bb 18 76 a7 82 5d c7 24 d4
>030418	65 99 e0 84 b2 4f 2f d4 0a a7 1c 9b 61 92 38 82
>030428	ab 33 1d c4 f0 e6 f8 cc fc df 14 2a 9d 51 70 82
>030438	c2 ac 46 76 ff f4 69 f0 4e 0e e8 71 9c 36 96 97
>030448	1d 6f dc bc 0c 5d 53 04 a8 44 4d 44 1e 42 75 0e
>030458	3f 7c b4 d8 f8 1e 5a 84 40 a5 65 4c 35 7b 8b 56
>030468	23 fc ad ff ac ed 04 17 d3 80 65 3f 91 57 30 c4
>030478	db b8 1f 01 37 b1 ee eb 04 86 cc d2 9d 56 c0 c3
>030488	26 9f 94 15 1e e8 6f b6 6a f2 76 75 fb 8a 05 9a
>030498	16 86 13 14 70 bc be b5 72 3a 71 82 c4 03 7f 67
>0304a8	bb 00 65 2e 93 65 77 c6 1c 9f 8f 2a 8d 16 03 b8
>0304b8	19 f0 7e 6d 21 bd 90 86 7d f3 ec 1a 0e a3 29 1e
>0304c8	c9 68 23 5b d7 69 14 3a 55 14 d4 47 c9 9a 79 b1
>0304d8	5b ee c7 4c f0 0f d6 7a b9 fb 83 b2 04 1e 27 11
>0304e8	b6 23 5f 14 fa 88 aa 85 54 37 11 dc 69 41 0c b3
>0304f8	ba f4 36 ce 89 f4 8d 11 9d 07 4a a6 eb 55 5c 39
>030508	4b 87 a8 61 bb cc 0c aa 37 a0 97 f4 21 61 4a 5e
>030518	8d 9b c5 1d d7 5a d9 6a 72 e0 5b ac df 5d 0c 8e
>030528	b8 c1 20 e2 be 44 85 31 a7 e7 16 19 23 69 5b a2
>030538	28 fb a5 4c b4 d9 39 e5 aa d1 0c
>030543	46 1d 44 10 3e 18 53 01		rnd1		.byte random([100] x RAND_SIZE)
>03054b	59 02 48 5c 17 49 40 0b 4c 1a 12 60 25 16 56 58
>03055b	0b 3e 3b 3a 44 1c 0e 3d 54 02 3d 49 03 5c 50 38
>03056b	4d 0f 38 63 0c 1f 4b 38 5b 48 1c 0d 55 07 53 30
>03057b	36 4b 19 19 4d 59 4a 1f 2f 4d 33 36 10 36 4e 13
>03058b	11 5b 13 3d 54 06 5e 62 2b 3b 34 43 43 19 24 0c
>03059b	41 37 3a 42 01 34 55 27 1a 01 1f 54 22 2f 36 17
>0305ab	01 24 5a 58 1a 14 5c 05 5a 36 31 08 2a 56 5d 3b
>0305bb	29 0c 30 2e 5c 15 2d 40 37 23 38 4e 0d 3f 3c 5b
>0305cb	2e 54 55 45 54 1e 5d 21 03 49 0a 3c 0e 12 1e 51
>0305db	1e 3b 54 2c 03 0e 29 2e 4a 17 03 39 1e 53 55 3c
>0305eb	57 12 35 2a 03 15 2f 50 10 15 1e 58 43 4f 48 4d
>0305fb	61 4c 26 35 58 55 15 3c 34 07 3f 56 44 4f 39 05
>03060b	15 1a 00 25 4a 49 2a 1b 4b 36 48 02 1c 3c 04 2b
>03061b	4f 54 40 39 40 4b 59 48 11 07 42 3c 08 36 39 58
>03062b	10 31 03 42 49 60 39 59 36 4b 31 3a 5a 4d 5c 33
>03063b	0c 26 2e 59 3b 62 22 1b 0d 12 5e 06 4a 1f 39 5f
>03064b	09 22 58 37 5e 24 32 0b 20 13 15 4c 44 1f 24 39
>03065b	31 13 4b 5e 62 15 4e 11 50 4b 1c 32 1a 36 49 3e
>03066b	2e 3e 1b 26 23 50 56 14 37 32 13 5b 07 24 08 5f
>03067b	2b 49 49 11 4f 36 0d 4d 10 17 2e 2a 22 5c 41 49
>03068b	46 4c 4a 3d 47 07 1a 12 44 0b 32 15 46 40 03 1e
>03069b	03 42 16 37 5c 47 3e 53 15 1d 0b 1d 29 5f 11 11
>0306ab	1d 2d 2e 16 33 2c 37 0a 3f 0c 14 55 42 58 55 26
>0306bb	5a 52 5a 1c 29 48 45 00 0a 00 3d 2b 45 5d 3e 60
>0306cb	58 2b 4c 4c 58 41 1d 52 09 4a 33 49 3f 24 52 5d
>0306db	5d 2d 07 4e 45 1e 27 55 0d 0c 0e 61 4a 0b 26 4f
>0306eb	57 1d 2f 63 21 44 63 0b 29 61 3e 04 55 1d 17 1a
>0306fb	36 38 0f 57 58 03 5f 05 0a 58 2e 1b 4d 2c 13 28
>03070b	44 5d 03 4d 1a 30 4b 53 31 1c 2e 17 44 55 5a 4b
>03071b	1a 0b 4f 09 1a 63 0e 11 1c 53 42 14 3a 5a 33 10
>03072b	18 2e 52 59 56 48 00 1e 30 58 0d 36 62 44 04 37
>03073b	06 62 44 19 58 17 3e 43 18 0b 13 17 0c 1b 11 41
>03074b	0b 1c 06 19 14 61 24 28 02 22 35 28 3a 04 14 62
>03075b	2b 04 23 10 54 4f 0a 05 4e 4b 23 3a 53 4e 12 23
>03076b	3b 60 4d 5c 24 47 46 63 4e 12 1a 56 52 2e 12 10
>03077b	00 3c 1f 17 53 45 3c 31 14 13 14 0d 2f 23 08 24
>03078b	59 50 1b 48 5f 49 04 3e 3e 0d 0f 55 26 5c 26 62
>03079b	15 40 60 1e 27 5f 08 61 32 50 51 51 34 41 0c 0c
>0307ab	2e 13 4a 08 03 0a 30 2b 24 06 36 31 2e 5a 19 55
>0307bb	2f 0a 18 31 0c 3a 31 54 13 3f 31 31 43 0f 3e 31
>0307cb	4e 3d 2f 54 3a 5a 30 23 17 20 17 5f 5d 4d 5c 51
>0307db	06 5c 3c 37 60 38 26 2e 0f 5e 60 09 00 0a 36 37
>0307eb	43 47 03 08 3a 4f 5a 27 0f 5c 60 07 23 0f 4b 5f
>0307fb	11 32 2b 23 43 05 54 04 5f 20 13 32 32 4f 34 33
>03080b	1f 60 2e 59 50 4f 3d 31 0a 48 17 3a 5c 21 02 04
>03081b	00 58 0c 1e 19 4a 27 24 03 61 53 58 52 0a 5e 2e
>03082b	43 1d 00 43 01 45 05 1c 41 3d 54 22 04 0e 4e 60
>03083b	2c 01 40 22 3b 4a 4d 44 00 1d 4f 62 45 1e 0e 2a
>03084b	0d 4f 2d 1d 27 51 16 3f 36 1e 45 0f 5a 0c 32 2c
>03085b	06 38 25 0b 27 38 1b 12 20 28 5a

;******  End of listing
